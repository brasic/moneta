#!/usr/bin/env ruby
# typed: true
# frozen_string_literal: true

# vim: set filetype=ruby :

require "fileutils"
require "open3"
require "ffi-xattr"

# Utilities for working with a mysql server instance inside a ramdisk
module MemorizeMysql
  module_function

  include Kernel

  WD = "/var/lib"
  MYSQL = "/var/lib/mysql"
  MTAB = "/etc/mtab"
  BOOT_ID_ATTR = "user.boot_id"
  GTID_ATTR = "user.gtid_executed"

  def in_memory?
    File.readlines(MTAB).any? { |line| line.include?(MYSQL) }
  end

  def current_gtid
    mysql("select @@global.gtid_executed")
  end

  def current_boot_id
    File.read("/proc/sys/kernel/random/boot_id").chomp
  end

  def ensure_in_memory
    return if in_memory?
    backup
  end

  def backup_file_name
    File.join(WD, "mysql.sql.zst")
  end

  def backup_attrs
    Xattr.new(backup_file_name)
  end

  def backup_current?
    return false unless File.exist?(backup_file_name)
    unless backup_attrs.get(BOOT_ID_ATTR) == current_boot_id
      puts "Backup is from a different boot"
      return false
    end
    unless backup_attrs.get(GTID_ATTR) == current_gtid
      puts "mysql server has moved on since backup"
      return false
    end
    puts "backup is current"
    true
  end

  def backup
    gtid = current_gtid
    puts "backup at #{backup_file_name} exists, overwriting file" if File.exist?(backup_file_name)
    Open3.pipeline_r(
      %w[mysqldump -uroot --all-databases --triggers --routines --events],
      %w[zstd --ultra -22]
    ) do |stdout, wait_threads|
      File.open(backup_file_name, "wb") do |sink|
        IO.copy_stream(stdout, sink)
        stdout.close
      end
      raise "failed to backup" if wait_threads.any? { |waiter| !waiter.value.success? }
    end
    puts "dump complete. writing attrs: gtid=#{gtid} boot_id=#{current_boot_id}"
    backup_attrs.set("user.gtid", gtid)
    backup_attrs.set("user.boot_id", current_boot_id)
  end

  def call
    ensure_in_memory

    re_exec_as_root if Process.euid != 0

    Dir.chdir(WD)

    run "supervisorctl stop mysql"
    tarball = nil

    unless Dir.empty?(MYSQL)
      tarball = "mysql-#{Time.now.to_i}.tar.xz"
      puts "mysql dir is nonempty, archiving it to #{tarball}"
      run "tar cJf #{tarball} #{MYSQL}"
      run "rm -r #{MYSQL}/*"
    end

    tarball ||= Dir["/var/lib/mysql*.tar.xz"].max_by { |x| File.mtime(x) }

    die "could not find tarball to reinflate" unless tarball

    run "mount -t tmpfs -o size=5G tmpfs #{MYSQL}"
    run "tar xf #{tarball}"
    FileUtils.chown_R "mysql", "mysql", MYSQL
    FileUtils.chmod 0o700, MYSQL
    run("supervisorctl start mysql")
  end

  def run(cmd)
    puts "-> #{cmd}"
    system(cmd, exception: true)
  end

  def re_exec_as_root
    Kernel.exec("sudo #{$PROGRAM_NAME}")
  end

  def mysql(sql)
    out, err, status =
      Open3.capture3("mysql", "-uroot", "--skip-column-names", "-e", sql)
    raise "mysql #{sql.inspect} failed: #{err}" unless status.success?
    out.chomp
  end

  def die(msg)
    puts msg
    exit 1
  end
end

require "pry"
binding.pry
